# Lec5: 中央处理器
## CPU概述
![1760601168018](image/lec5/1760601168018.png)
CPU执行指令的过程：取指、译码、执行、回写
取指令一定在最开始做，然后在执行之前译码
![1760594652740](image/lec5/1760594652740.png)
异常是CPU内部发生，中断是外部事件引起
![1760595197603](image/lec5/1760595197603.png)
![1760595709213](image/lec5/1760595709213.png)

### CPU基本组成
![1760595419656](image/lec5/1760595419656.png)
CPU包含：
- 数据通路(执行部件) 
- 控制器（控制部件）

#### 控制器
对指令进行**译码**，生成指令对应的**控制信号**，控制数据通路的动作。能对执行部件发出控制信号，是指令的**控制部件**

#### 数据通路
指令执行过程中，数据**所经过的路径，包括路径中的部件**。它是指令的**执行部件**。

数据通路是由操作元件和存储元件通过**总线方式或分散方式**连接而成的进行数据存储、处理、传送的路径。
数据通路由组合逻辑元件（操作元件）和时序逻辑元件（状态元件，存储元件）组成
- 组合逻辑元件与时钟信号无关，直接进行操作
- 时序逻辑元件受时钟信号控制，时钟信号到来时状态改变，写入元件状态；未到来时就可以存储

数据通路的功能就是进行数据存储、处理和传送。

##### 操作元件
比如加法器、多路选择器、ALU、译码器等等
组合逻辑元件的特点：
- 其输出只取决于当前的输入。即：**若输入一样**，则其输出也一样
- 定时：所有输入到达后，经过一定的逻辑门延时，输出端改变，并保持到下次改变，**不需要时钟信号来定时**

##### 状态元件
具有**存储功能**，在时钟控制下输入被写到电路中，直到下个时钟到达，输入端状态**由时钟决定何时被写入**，输出端状态**随时可以读出**

定时方式：规定信号何时写入状态元件
通常采用**边沿触发**方式
![1760596161535](image/lec5/1760596161535.png)
最简单的状态单元：
- D触发器：一个时钟输入、一个状态输入、一个状态输出
![1760596255848](image/lec5/1760596255848.png)
这是一个D触发器例子，D读取，Q输出
输入D的数据要在时钟到达之前就稳定，在到达之后也要保持一段时间稳定，在Clock-to-Q之后Q的值和D保持一致
因此是有延迟存在的

状态元件通常有寄存器和存储器两种
- 寄存器：有一个写使能信号（WE），当他是0的时候时钟边沿到来但是输出不变，如果是1那么输出开始变为输入，如果每个时钟边沿都写入就不需要WE
- 寄存器组：两个读口，一个写口，RA，RB和RW都是寄存器的地址，busA和busB是其中的内容
![1760596707172](image/lec5/1760596707172.png)
取数时间并不是锁存延迟，而是寄存器组的延迟
RW选择的寄存器会置为1，这样他和输入的busW进行与操作之后就可以知道哪一个是指定的寄存器

- 存储器：有一个Data out，一个Data in，一个地址 address
- 读操作：地址address有效之后，经过取数时间，data out上的数据变为有效
- 写操作：写使能信号为1，时钟边沿到来，data in传来的值写入address指定的存储单元中

### 现代计算机的时钟周期
什么是指令周期？ 取并且执行一条指令的时间

那么什么是时钟周期？
一个下降沿（上升沿）到下一个下降沿（上升沿）的时间
在时钟周期之中，经过锁存时间，状态元件读入数据，操作元件进行运算，再传递到下一个状态元件，这之中是没有时钟控制的
因此时钟周期=锁存延迟+最长传输延迟+建立时间（setup）+时钟偏移

约束条件：存延迟+最短传输延迟-时钟偏移 必须大于保持时间，才可以保证数据在时钟边沿到来时保持稳定 最小最小要大于保持时间

## 单周期处理器设计
![1760598203687](image/lec5/1760598203687.png)
处理器设计涉及到**数据通路**的设计和**控制器**的设计
对MIPS的三种指令格式，要实现对应的数据通路，用RTL表示
![1760598288025](image/lec5/1760598288025.png)

### 加法指令
![1760598439253](image/lec5/1760598439253.png)
先从PC所指的内存单元中取出这个指令，然后从rs和rt指的寄存器中取数之后相加
如果结果不溢出，就存进rd所指的寄存器中
最后PC+4，使得他指向下一条指令
RTL主要是描述数据通路的行为，表示相应的立即数或者寄存器

### 装入指令
![1760598470221](image/lec5/1760598470221.png)

### 取指令部件
1760598607450.png
![1760598805178](image/lec5/1760598607450.png)
每条指令都有的公共操作：取指令和PC+4，如果指令里面有修改PC的值就直接更新，因此不能先更新PC之后取指令
下地址计算的逻辑部件会更新PC，在下一个时钟边沿触发的时候更新
如果是分支或者跳转指令，就不是PC+4，下地址逻辑部件就会计算相应的PC值

### 数据通路的设计
注意，所有图中的线路都是有数据的，而不是说没有数据，所以我们通过**多路选择器**来选择符合我们当前指令的功能的值，并且参与执行
因此，多路选择器的选择通过一些**控制信号**来决定，每种指令的控制信号是什么，我们要搞清楚。
#### 加法和减法指令（R型）
不考虑公共操作先，只考虑指令执行阶段
![1760598805178](image/lec5/1760598805178.png)
先不看粉红色的线，RegWr是写使能信号，如果是1就把busW写入rd指的寄存器中
黑色的线就是R型指令的数据通路
ALUctr是ALU的控制信号，用来选择ALU的操作，比如我可以选ALUctr=add ctr是control

#### 带立即数的逻辑指令（ori指令）
![1760598956691](image/lec5/1760598956691.png)
注意，这里的立即数是零扩展而不是符号扩展！
![1760598993076](image/lec5/1760598993076.png)
![1760599038860](image/lec5/1760599038860.png)
黑色的线就是刚才R型的数据通路，需要增加蓝色部分来支持逻辑运算
都是通过多路选择器来实现选择
RegDst是选择写回的寄存器，0是写回rd，表示R型指令，1是写回rt，表示ori型指令
ALUctr是ALU的控制信号，用来选择ALU的操作，比如我可以选ALUctr=or
ALUSrc是选择ALU的第二个操作数，0是从busB取数，1是从立即数取数

#### 访存指令中的数据装入指令 (lw指令)
![1760599249229](image/lec5/1760599249229.png)
注意这里是立即数符号扩展
![1760599304125](image/lec5/1760599304125.png)
再加入蓝色部分，在支持R和ori指令基础上添加
MemWr是存储器写使能信号，0是不写，1是写
ExtOp取0表示0扩展，1表示符号扩展
存储器只进行读操作，所以他的写使能信号必须始终是0
从memory里面读数据，MemtoReg选1表示选择来自存储器的数据写入busW当中
在存储器里面的Adr是通过加运算得到的，可以看lw指令的具体含义

#### 访存指令中的存数指令 (sw指令)
![1760599662632](image/lec5/1760599662632.png)
与lw相反，lw是从内存单元取内容存到寄存器，sw是把寄存器rt中的内容存到内存单元中
![1760599722947](image/lec5/1760599722947.png)
只需要再多加一条线就可以支持sw了（没有经过多路选择器，只是图画不下了）
把rt的内容通过busB读出来然后写入存储器（memory）
RegDst=x的意思是0或者1都可以，不影响，因为我不管他那边的输出是哪个寄存器
RegWr必须等于0，不允许busW改变
MemWr必须等于1，允许对memory进行写操作

#### 分支（条件转移）指令（beq指令）
![1760600020134](image/lec5/1760600020134.png)
如果rs和rt里面存的数相等就跳到立即数表示的地址，否则下一条指令
![1760600137849](image/lec5/1760600137849.png)
在原来的基础上，再添加蓝色部分。存储器因为画不下就没画，但是实际上还是存在的

busA和busB分别读出rs和rt，ALU计算判断是不是等于0，然后由下地址逻辑部件计算出下一个新的PC，再送到PC当中
如果Zero输入是0，代表不是Zero，那就直接PC+4，指向下一条指令
这个时候写使能信号都为0，ALUctr=subu，注意Branch=1因为是一个分支指令

##### 下地址计算逻辑
PC是一个32位地址，每次都是+4，那么每个地址的后两位都是00
所以每个PC都可以用30位表示，后面跟两个00就行了，这样计算逻辑更加简单
![1760600489578](image/lec5/1760600489578.png)
![1760600607267](image/lec5/1760600607267.png)
那么下地址计算的逻辑部件就如上所示
Mux取1就代表要计算branch指令的结果是PC值，需要Branch信号为1，并且Zero信号为1，
为什么不用ALU而用Adder是因为只执行一种加法操作，不需要ALU的其他功能

#### 无条件跳转（j指令）
![1760600855536](image/lec5/1760600855536.png)
只有target这26个比特的范围内变化跳转，前四个比特必须不变，最后两个一定是00
所以他只能在这个范围内跳转，是绝对寻址
![1760600966527](image/lec5/1760600966527.png)
新增蓝色线部分，支持j指令
把当位的4个比特和target的26个比特拼接起来，Jump信号为1说明选择了刚才拼接的30个比特，然后返回给PC更新
Branch和Jump信号不会同时为1

**所有写使能信号只要跟他没关系，必须置为0**
![1760601116655](image/lec5/1760601116655.png)
这样，所有数据通路就设计好了

### 单周期数据通路的控制器设计
设计方法：
1) 根据每条指令的功能，分析**控制信号的取值**，并在表中列出。
2) 根据列出的指令和控制信号的关系，写出每个**控制信号的逻辑表达式**

R型指令，每个控制信号赋什么值？
![1760602000321](image/lec5/1760602000321.png)
所有的写使能信号一定看他和指令有没有关系
MemWr就没关系，一定要置为0
![1760602226401](image/lec5/1760602226401.png)
最后阶段，执行PC+4，除了Branch和Jump指令以外，这个部分都是这样的

![1760602336878](image/lec5/1760602336878.png)
经过锁存时间，读入PC的值，然后取指令，经过各种取数时间和延迟之后，经过setup时间，写回目标寄存器，然后更新PC

ori指令，每个控制信号赋什么值？
![1760602405648](image/lec5/1760602405648.png)
R型指令写入Rd寄存器，而i型指令写入Rt寄存器，因此RegDst=1

load指令：
![1760602552539](image/lec5/1760602552539.png)
从存储器读内容存入Rt当中

store指令：
![1760602636177](image/lec5/1760602636177.png)

branch指令：
![1760602651450](image/lec5/1760602651450.png)
注意，在branch指令的最后阶段，取指部件会计算下一个PC的值
![1760602819163](image/lec5/1760602819163.png)
此时通过红色的路线来计算下一个PC的值，然后更新PC
注意Zero不是我设置的控制信号，而是ALU的输出信号，用来判断是否相等，如果相等那说明差是0，Zero是1

jump指令：
![1760602665673](image/lec5/1760602665673.png)
![1760602969263](image/lec5/1760602969263.png)
同样的计算下一个PC的值并且更新PC

控制器实际上由主控制单元和ALU局部控制单元组成
主控制单元产生ALUop，也就是当前的指令操作类型
然后ALU局部单元来确定对应的要加还是减或者其他的
最后得到一个ALUctr
如果是R型指令，ALUctr要取决于func字段
如果不是，那么ALUctr就直接等于ALUop
![1760603523809](image/lec5/1760603523809.png)
ALUop在4种到8种指令之间，因此至少有3个bit

ALUop的逻辑表达式
![1760603696486](image/lec5/1760603696486.png)
lw和sw在ALU里面都是用加法得到地址，因此ALUop是一样的，表示他们的运算类型是一样的
![1760603802679](image/lec5/1760603802679.png)
ALUop第2位的比特，只有beq的时候才取1，这种情况对应的op操作码是beq的op=000100，这个时候ALUop的第2位如果是1应该是由op的6、5、4、3、1、0这几个位取反，再和第2位一起与运算，如果是1那么ALUop的第2位就取1，否则取0

同样的我们可以得出ALUop其他位的逻辑表达式

ALU局部控制器的逻辑表达式
![1760603944448](image/lec5/1760603944448.png)
对照表就可以得到ALUctr的逻辑表达式

这样，ALU的运算就可以全部转换为跟操作码op相关的表示
如此，任何一个控制信号的逻辑表达式都可以写出来了
以RegWr为例
![1760604129057](image/lec5/1760604129057.png)
+表示逻辑运算或，只有这三种情况下RegWr是1，所以三个或就可以得到RegWr的逻辑表达式
![1760604268992](image/lec5/1760604268992.png)
用与门来读入相应的op对应的是哪种指令

### 完整的单周期处理器
![1760604304886](image/lec5/1760604304886.png)
黑色部分是数据通路，蓝色部分是控制器

## 多周期处理器设计
单周期处理器，CPI为1，取最长的指令执行时间load指令为准，因此时钟周期为load指令的执行时间，但是这样会远大于其他指令实际所需的执行时间
![1761199524912](image/lec5/1761199524912.png)
因此有了多周期处理器，允许不同指令有不同的时钟周期
![1761199594593](image/lec5/1761199594593.png)
以load指令为例，包括了取指令，取数，ALU运算，读memory，写回寄存器这些阶段
解决思路：
- 把指令的执行分成**多个阶段**，每个阶段在一个时钟周期内完成
- 时钟周期应该以**最复杂的阶段**所花的时间为准，尽量分成大致相等的若干阶段
- 规定每个阶段只使用一次功能部件，最多完成一次访存/寄存器读写/ALU运算

多周期处理器的好处：
- 时钟周期短（绝对时间，以前是一整条指令，现在是最长的阶段）
- 不同指令所用周期数**可以不同**
- 允许功能部件在一条指令执行的不同阶段被重复使用，提高了处理器的效率

load指令各阶段：
![1761200656836](image/lec5/1761200656836.png)

多周期数据通路：
![1761200952922](image/lec5/1761200952922.png)

### 寄存器堆和存储器的写定时
实际机器中，寄存器堆和存储器的写操作**不是由时钟边沿触发**，是组合电路，其过程为：写使能(WE)为 1，并且 Datain 信号**已稳定**的前提下，经过Write Access时间，Din信号被写入 Adr 对应的单元之中，这里面没有clock
重要之处: 地址和数据必须**在写使能为1前稳定**
因此，存在(地址Adr数据Din)和(写使能WrEn信号)的**竞争问题**。
![1761201034210](image/lec5/1761201034210.png)
在单周期里面很难解决这个问题，因为单周期是一条指令一个时钟周期，而这里面地址和数据是分开的，因此在单周期里面很难保证地址和数据在写使能为1前稳定
在多周期处理器里面，保证数据和地址在第N个周期结束时已稳定，在N+1个周期开始时，写使能WrEn信号为1，这样就可以保证数据和地址在写使能为1前稳定，在写使能信号无效之前地址和数据都不能改变

### 多周期数据通路设计
#### 取指令周期
不能在每个时钟周期都更新PC和IR，因为可能只是阶段结束而不是指令结束，因此用写使能信号来控制PC和IR的更新
![1761201472359](image/lec5/1761201472359.png)
取值周期开始的时候，先把PC的值取出来，送到存储单元进入指令寄存器IR和送到ALU端
![1761201534855](image/lec5/1761201534855.png)
这个是取指令阶段结束的时候，新的值PC+4写入到PC当中，而不会更新指令，所以IR指令寄存器不变，他的写使能信号为0
指令进入了IR寄存器，PC也完成了更新，取指令阶段就结束了

各种控制信号的取值：
![1761201782180](image/lec5/1761201782180.png)
只有PCWr和IRWr为1，其他的都是0，因为其他的根本就没关系，不需要写入
ALUop选择Add，因为要给PC+4

所有的控制信号的集合成为一个**状态**

#### 寄存器取/指令译码周期
第二个周期开始的时候，IR之中有了这个指令，就知道了指令的操作码、立即数、寄存器编号等信息
然后就根据寄存器编号取数，送到ALU端
![1761201979118](image/lec5/1761201979118.png)
这些之后，就要根据操作码功能码来译码，判断指令类型。还有一个重要的投机运算
![1761202025580](image/lec5/1761202025580.png)
投机运算：将PC的值和立即数的值符号扩展之后相加，新的值送到BranchTarget寄存器
因为还不能判断这是一个Branch指令，所以先放在这里，等判断是不是Branch指令再决定是否更新PC

如果译码的结果是Beq指令，就直接进入第三个阶段

#### Branch指令执行并完成周期：第三个周期
若不“投机”，则在此周期前还要加一个周期，用来计算转移地址后保存到Branch的Target寄存器中，所以投机运算是很有必要的
所以Branch指令只需要三个周期
判断两个数是否相等，就是判断差是不是0，然后判断是否跳转。
![1761203352759](image/lec5/1761203352759.png)

#### R-type指令的执行周期：第三个周期
busA和busB的内容做ALU，结果存到Rd寄存器的指定寄存器之中
![1761203394936](image/lec5/1761203394936.png)
为了解决竞争的问题，这个周期必须保证RegWr是0，不写入寄存器先，然后就可以保证地址和数据在写使能之前稳定
所有的写操作在这个周期里面置为0，先不写入

#### R-type指令的完成周期：第四个周期
![1761203514274](image/lec5/1761203514274.png)
ALU的输出要保持稳定，Rw，busW都要稳定的，然后进行写入

#### Ori指令的执行周期：第三个周期
带立即数，进行执行，对立即数零扩展，做ALU操作，结果送入Rt指定的寄存器中
为了解决竞争的问题，让RegWr为0，busW和Rw准备就绪，准备在下一个阶段写入

#### Ori指令的完成周期：第四个周期
![1761203907541](image/lec5/1761203907541.png)
执行写入，其他控制信号不能变化，维持稳定

#### lw/sw指令的执行周期：第三个周期
![1761204055665](image/lec5/1761204055665.png)

#### sw指令的存数周期：第四个周期
![1761204080193](image/lec5/1761204080193.png)

#### lw指令的取数周期：第四个周期
![1761204102213](image/lec5/1761204102213.png)

#### lw指令的写回周期：第五个周期
![1761204125449](image/lec5/1761204125449.png)

### 完整的多周期数据通路
![1761204381739](image/lec5/1761204381739.png)
那么，如何在不同周期产生不同的控制信号取值？这就是控制器的任务，涉及控制器的设计
![1761204447157](image/lec5/1761204447157.png)
每个取值的集合都称为一个状态，这么多的状态，组成了**状态转换图**，我们通过状态转换电路（控制器）的设计来实现不同状态的转换。

### 控制器设计
对于单周期控制器，控制信号在整个指令执行过程中不变，用真值表就能反映指令和控制信号的关系。
多周期控制器能不能这样做？
![1761204951320](image/lec5/1761204951320.png)

#### 硬连线控制器设计
由**时钟、当前状态和操作码**确定下一状态。不同状态输出不同控制信号值
控制逻辑采用“**摩尔机**”方式，即：输出函数仅依赖于**当前状态**
![1761205020807](image/lec5/1761205020807.png)
通过组合逻辑单元的判断，根据当前的状态和指令类型（opcode）输出下一个状态应该是什么状态，查找**状态转换图**。
每来一个时钟，当前状态变到下一个状态

![1761205218500](image/lec5/1761205218500.png)
这个表就体现了这样的函数关系，下一状态是当前状态和操作码的函数。

![1761205377469](image/lec5/1761205377469.png)
这张图，左边是输入，操作码Op六个bit和状态S四个bit，紫色的点如果不在线上说明是高电平，是1，黑色的点有的位置代表1，没有的代表0
有一些不依赖于操作码的状态比如说0号状态，不管操作码是什么，下一个都一定是1号状态译码，看图也可以看出来。

#### 微程序控制器设计
硬连线，是一个多输入/多输出的**巨大逻辑网络**。对于复杂指令系统来说，结构庞杂，实现困难；修改、维护不易；**灵活性差**。甚至无法用有限状态机描述！

仿照程序设计的方法，编制每个指令对应的微程序。
每个微程序由若干条微指令构成，各微指令包含若干条微命令（一条微指令相当于**一个状态**，一个微命令就是状态中的**控制信号**）
所有指令对应的微程序放在只读存储器中，执行某条指令时，取出对应微程序中的各条微指令，对微指令译码产生对应的微命令，这个微命令就是控制信号。这个只读存储器称为**控制存储器**（Control Storage），简称**控存CS**

基本结构：
![1761206474674](image/lec5/1761206474674.png)
